## [N으로 표현 (42895)](https://programmers.co.kr/learn/courses/30/lessons/42895)

### 문제 설명

아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다.

    12 = 5 + 5 + (5 / 5) + (5 / 5)
    12 = 55 / 5 + 5 / 5
    12 = (55 + 5) / 5

5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다. 이처럼 숫자 `N`과 `number`가 주어질 때, `N`과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을
return 하도록 solution 함수를 작성하세요.

### 제한사항

- `N`은 1 이상 9 이하입니다.
- `number`는 1 이상 32,000 이하입니다.
- 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.
- 최솟값이 8보다 크면 -1을 return 합니다.

### 입출력 예

| N    | number    | return |
| :---: | :---: | :---: |
| 5    | 12    | 4 |
| 2    | 11    | 3 |

### 입출력 예 설명

#### 예제 #1

문제에 나온 예와 같습니다.

#### 예제 #2

11 = 22 / 2와 같이 2를 3번만 사용하여 표현할 수 있습니다.

***

## 풀이

### 알고리즘 분류: DP

★을 모든 가능한 사칙연산이라고 하자.

예제 #1과 같이 입력값이 `N`=5, `number`=12 일때

- 5를 1번만 사용하여 만들 수 있는 수 (1번 Set): 5
- 5를 2번만 사용하여 만들 수 있는 수 (2번 Set): 55, (1번 Set의 모든 원소) ★ (1번 Set의 모든 원소)
- 5를 3번만 사용하여 만들 수 있는 수 (3번 Set): 555, (1번 Set의 모든 원소) ★ (2번 Set의 모든 원소), (2번 Set의 모든 원소) ★ (1번 Set의 모든 원소) (여기서 (55 +
    5) 만들어짐)
- 5를 4번만 사용하여 만들 수 있는 수 (3번 Set): 5555, (1번 Set의 모든 원소) ★ (3번 Set의 모든 원소), (2번 Set의 모든 원소) ★ (2번 Set의 모든 원소), (3번 Set의
  모든 원소) ★ (1번 Set의 모든 원소) (여기서 (55 + 5) / 5 만들어짐)

즉 이를 일반화하면 다음과 같다.

#### `N`를 n번만 사용하여 만들 수 있는 수 (n번 Set)

- (`N`가 n개 있는 수)
- ((n-1)번 Set의 모든 원소) ★ (1번 Set의 모든 원소)
- ((n-2)번 Set의 모든 원소) ★ (2번 Set의 모든 원소)
- (계속)
- ((1번 Set의 모든 원소) ★ ((n-1)번 Set의 모든 원소))

**결국 정답을 구하는 과정은 다음과 같다.**

- `N`을 1번만 사용하여 만들 수 있는 모든 수를 생성, 원하는 `number`가 존재하는지 확인 - 있으면 정답!
- `N`을 2번만 사용하여 만들 수 있는 모든 수를 생성, 원하는 `number`가 존재하는지 확인 - 있으면 정답!
- ...
- `N`을 n번만 사용하여 만들 수 있는 모든 수를 생성, 원하는 `number`가 존재하는지 확인 - 있으면 정답, 없으면 -1

### 구현

`arithmeticAddSet` 메소드는 ★을 수행하는 연산자이다.

`N`가 n개 있는 수 생성 및 추가

```java 
int repeated = Integer.parseInt(Integer.toString(N).repeat(nTimes));
sets[setIdx].add(repeated);
```

서로 다른 Set끼리 사칙연산해서 추가

```java
for(int i=1;i<nTimes; i++)
        sets[setIdx].addAll(arithmeticAddSet(sets[i-1],sets[nTimes-i-1]));
```

